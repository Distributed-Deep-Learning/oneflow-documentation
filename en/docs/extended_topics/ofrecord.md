Deep Learning applications need complex multi-stage data preprocessing pipeline, the first step of data pipeline is data loading. OneFlow supports multiple data formats in data loading, among which `OFRecord` format is the native data format of OneFlow.

The data format definition of `OFRecord` refers to Tensorflow's [<1>TFRecord](https://www.tensorflow.org/tutorials/load_data/tfrecord), you can quickly start OneFlow's `OFRecord` if you are familiar with `TFRecord`

In this section we will introduce：

* The data type used in OFRecord

* How to convert data to OFRecord object and serialize it

* The file format of OFRecord

After learning that, it is helpful for us to learn [how to make ofdataset](how_to_make_ofdataset.md).

## Some data types in OFRecord
Internally, OneFlow use [Protocol Buffers](https://developers.google.com/protocol-buffers/) to describe the serialization format of OFRecord.Some relevant `.proto` files are under the `oneflow/core/record/record.proto`, the specific definition is as follows：

```
syntax = "proto2";
package oneflow;

message BytesList {
  repeated bytes value = 1;
}

message FloatList {
  repeated float value = 1 [packed = true];
}

message DoubleList {
  repeated double value = 1 [packed = true];
}

message Int32List {
  repeated int32 value = 1 [packed = true];
}

message Int64List {
  repeated int64 value = 1 [packed = true];
}

message Feature {
  oneof kind {
    BytesList bytes_list = 1;
    FloatList float_list = 2;
    DoubleList double_list = 3;
    Int32List int32_list = 4;
    Int64List int64_list = 5;
  }
}

message OFRecord {
  map<string, Feature> feature = 1;
}
```

Let's explain the above important data types at first：

* OFRecord: is the instantiated object of OFRecord, which can be used to store all data that need to be serialized.It consists of many string->Feature key-value object.

* Feature: Feature can store any of a type of BytesList, FloatList, DoubleList, Int32List, Int64List;

* OFRecord, Feature, XXXList and other types are used to generate corresponding interfaces of the same name by `Protocol Buffers`, making it possible to build corresponding object at the Python level.

## Convert data into Feature format

We can call `ofrecord.xxxList` and `ofrecord.Feature` to convert data to `Feature` format.But for convenience, we need to simply encapsulate the interface generated by `protocol buffers`

```python
import oneflow.core.record.record_pb2 as ofrecord

def int32_feature(value):
    if not isinstance(value, (list, tuple)):
      value = [value]
    return ofrecord.Feature(int32_list=ofrecord.Int32List(value=value))


def int64_feature(value):
    if not isinstance(value, (list, tuple)):
        value = [value]
    return ofrecord.Feature(int64_list=ofrecord.Int64List(value=value))


def float_feature(value):
    if not isinstance(value, (list, tuple)):
      value = [value]
    return ofrecord.Feature(float_list=ofrecord.FloatList(value=value))


def double_feature(value):
    if not isinstance(value, (list, tuple)):
      value = [value]
    return ofrecord.Feature(double_list=ofrecord.DoubleList(value=value))


def bytes_feature(value):
    if not isinstance(value, (list, tuple)):
        value = [value]
    if not six.PY2:
        if isinstance(value[0], str):
            value = [x.encode() for x in value]
    return ofrecord.Feature(bytes_list=ofrecord.BytesList(value=value))
```

## Create OFRecord object and serialize it

In the following example, we will create a OFRecord object which has two features, and serialize it by using `SerializeToString`

```python
    obserations = 28*28
    #... image = [random.random() for x in range(0,obserations)]
    label = [random.randint(0,9)]

    topack = {
        'images': float_feature(image),
        'labels': int64_feature(label),
    }

    ofrecord_features = ofrecord.OFRecord(feature=topack)
    serilizedBytes = ofrecord_features.SerializeToString()
```

With the above example, we can summarize the steps for serializing data：

* To serialize data, we can call `ofrecord.Feature` and `ofrecord.XXXList` to convert it to a `Feature` object.

* Take each Feature object obtained in the previous step as `string->Feature` key-value format, stored in Python dict.

* Create `OFRecord` object by using `ofrecord.OFRecord`

* Call OFRecord object's `SerializeToString` method to get the serialized result.

The serialized result can be saved as a file in ofrecord format.

## OFRecord format file

After serializing OFRecord object according to the format of OneFlow convention, we can get **OFRecord file**

Multiple OFRecord objects can be stored in one OFRecord file. The OFRecord file can be used in `OneFlow data-pipeline`, some specific operations can be seen at [how to make ofrecord dataset](how_to_make_ofdataset.md)

According to the OneFlow convention, each **OFRecord object** is stored in the following format.

```
uint64 length
byte   data[length]
```

The first eight bytes are stored in the data length, and then in the serialized data.

```python
length = ofrecord_features.ByteSize()
f.write(struct.pack("q", length))
f.write(serilizedBytes)
```

## The compele code
以下完整代码展示如何生成 OFRecord 文件，并调用 `protobuf` 生成的 `OFRecord` 接口手工读取 OFRecord 文件中的数据。

实际上，OneFlow 提供了 `flow.data.decode_ofrecord` 等接口，可以更方便地提取 OFRecord 文件（数据集）中的内容。详细内容请参见[加载与准备OFRecord数据集](how_to_make_ofdataset.md)。

### 将 OFRecord 对象写入文件
以下代码，模拟了3个样本，每个样本为`28*28`的图片，并且包含对应标签。将三个样本转化为OFRecord对象后，按照OneFlow约定格式，存入文件。将三个样本转化为 OFRecord 对象后，按照 OneFlow 约定格式，存入文件。

完整代码：[ofrecord_to_string.py](../code/extended_topics/ofrecord_to_string.py)

```python
import oneflow.core.record.record_pb2 as ofrecord
import six
import random
import struct

def int32_feature(value):
    if not isinstance(value, (list, tuple)):
      value = [value]
    return ofrecord.Feature(int32_list=ofrecord.Int32List(value=value))


def int64_feature(value):
    if not isinstance(value, (list, tuple)):
        value = [value]
    return ofrecord.Feature(int64_list=ofrecord.Int64List(value=value))


def float_feature(value):
    if not isinstance(value, (list, tuple)):
      value = [value]
    return ofrecord.Feature(float_list=ofrecord.FloatList(value=value))


def double_feature(value):
    if not isinstance(value, (list, tuple)):
      value = [value]
    return ofrecord.Feature(double_list=ofrecord.DoubleList(value=value))


def bytes_feature(value):
    if not isinstance(value, (list, tuple)):
        value = [value]
    if not six.PY2:
        if isinstance(value[0], str):
            value = [x.encode() for x in value]
    return ofrecord.Feature(bytes_list=ofrecord.BytesList(value=value))

obserations = 28*28

f = open("./dataset/part-0", "wb")

for loop in range(0, 3):
    image = [random.random() for x in range(0,obserations)]
    label = [random.randint(0,9)]

    topack = {
        'images': float_feature(image),
        'labels': int64_feature(label),
    }

    ofrecord_features = ofrecord.OFRecord(feature=topack)
    serilizedBytes = ofrecord_features.SerializeToString()

    length = ofrecord_features.ByteSize()

    f.write(struct.pack("q", length))
    f.write(serilizedBytes)

print('Done!') f.close()
```

### 从 OFRecord 文件中读取数据
以下代码，读取上例中生成的 `OFRecord` 文件，调用 `FromString` 方法反序列化得到 `OFRecord` 对象，并最终显示数据：

完整代码：[ofrecord_from_string.py](../code/extended_topics/ofrecord_from_string.py)

```python
import oneflow.core.record.record_pb2 as ofrecord
import struct

with open("./dataset/part-0", "rb") as f:
    for loop in range(0,3):
        length = struct.unpack("q", f.read(8))
        serilizedBytes = f.read(length[0])
        ofrecord_features = ofrecord.OFRecord.FromString(serilizedBytes)

        image = ofrecord_features.feature["images"].float_list.value
        label = ofrecord_features.feature["labels"].int64_list.value

        print(image, label, end="\n\n")
```



